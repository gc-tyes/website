{"ast":null,"code":"import _slicedToArray from \"/Users/mkeohane/Documents/repositories/Tyes/website/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/* eslint-disable import/no-commonjs */\n\n\nimport pathToRegexp, { compile } from 'path-to-regexp';\nimport NavigationActions from '../NavigationActions';\nimport invariant from '../utils/invariant';\n\nvar queryString = require('query-string');\n\nexport var getParamsFromPath = function getParamsFromPath(inputParams, pathMatch, pathMatchKeys) {\n  var params = pathMatch.slice(1).reduce( // iterate over matched path params\n  function (paramsOut, matchResult, i) {\n    var key = pathMatchKeys[i];\n\n    if (!key || key.asterisk) {\n      return paramsOut;\n    }\n\n    var paramName = key.name;\n    var decodedMatchResult;\n\n    if (matchResult) {\n      try {\n        decodedMatchResult = decodeURIComponent(matchResult);\n      } catch (e) {// ignore `URIError: malformed URI`\n      }\n    }\n\n    paramsOut[paramName] = decodedMatchResult || matchResult;\n    return paramsOut;\n  }, _objectSpread({}, inputParams));\n  return params;\n};\n\nvar getRestOfPath = function getRestOfPath(pathMatch, pathMatchKeys) {\n  var rest = pathMatch[pathMatchKeys.findIndex(function (k) {\n    return k.asterisk;\n  }) + 1];\n  return rest;\n};\n\nexport var urlToPathAndParams = function urlToPathAndParams(url, uriPrefix) {\n  var searchMatch = url.match(/^(.*)\\?(.*)$/);\n  var params = searchMatch ? queryString.parse(searchMatch[2]) : {};\n  var urlWithoutSearch = searchMatch ? searchMatch[1] : url;\n  var delimiter = uriPrefix || '://';\n  var path = urlWithoutSearch.split(delimiter)[1];\n\n  if (path === undefined) {\n    path = urlWithoutSearch;\n  }\n\n  if (path === '/') {\n    path = '';\n  }\n\n  if (path[path.length - 1] === '/') {\n    path = path.slice(0, -1);\n  }\n\n  return {\n    path: path,\n    params: params\n  };\n};\nexport var createPathParser = function createPathParser(childRouters, routeConfigs, _ref) {\n  var _ref$paths = _ref.paths,\n      pathConfigs = _ref$paths === void 0 ? {} : _ref$paths,\n      disableRouteNamePaths = _ref.disableRouteNamePaths;\n  var pathsByRouteNames = {};\n  var paths = []; // Build pathsByRouteNames, which includes a regex to match paths for each route. Keep in mind, the regex will pass for the route and all child routes. The code that uses pathsByRouteNames will need to also verify that the child router produces an action, in the case of isPathMatchable false (a null path).\n\n  Object.keys(childRouters).forEach(function (routeName) {\n    var pathPattern; // First check for paths on the router, then check the route config\n\n    if (pathConfigs[routeName] !== undefined) {\n      pathPattern = pathConfigs[routeName];\n    } else {\n      pathPattern = routeConfigs[routeName].path;\n    }\n\n    if (pathPattern === undefined) {\n      // If the user hasn't specified a path at all nor disableRouteNamePaths, then we assume the routeName is an appropriate path\n      pathPattern = disableRouteNamePaths ? null : routeName;\n    }\n\n    invariant(pathPattern === null || typeof pathPattern === 'string', \"Route path for \".concat(routeName, \" must be specified as a string, or null.\")); // the path may be specified as null, which is similar to empty string because it allows child routers to handle the action, but it will not match empty paths\n\n    var isPathMatchable = pathPattern !== null; // pathPattern is a string with inline params, such as people/:id/*foo\n\n    var exactReKeys = [];\n    var exactRe = isPathMatchable ? pathToRegexp(pathPattern, exactReKeys) : null;\n    var extendedPathReKeys = [];\n    var isWildcard = pathPattern === '' || !isPathMatchable;\n    var extendedPathRe = pathToRegexp(isWildcard ? '*' : \"\".concat(pathPattern, \"/*\"), extendedPathReKeys);\n    pathsByRouteNames[routeName] = {\n      exactRe: exactRe,\n      exactReKeys: exactReKeys,\n      extendedPathRe: extendedPathRe,\n      extendedPathReKeys: extendedPathReKeys,\n      isWildcard: isWildcard,\n      toPath: pathPattern === null ? function () {\n        return '';\n      } : compile(pathPattern)\n    };\n  });\n  paths = Object.entries(pathsByRouteNames);\n\n  var getActionForPathAndParams = function getActionForPathAndParams() {\n    var pathToResolve = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var inputParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // Attempt to match `pathToResolve` with a route in this router's routeConfigs, deferring to child routers\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            routeName = _step$value[0],\n            path = _step$value[1];\n\n        var exactRe = path.exactRe,\n            exactReKeys = path.exactReKeys,\n            extendedPathRe = path.extendedPathRe,\n            extendedPathReKeys = path.extendedPathReKeys;\n        var childRouter = childRouters[routeName];\n        var exactMatch = exactRe && exactRe.exec(pathToResolve);\n\n        if (exactMatch && exactMatch.length) {\n          var extendedMatch = extendedPathRe && extendedPathRe.exec(pathToResolve);\n          var childAction = null;\n\n          if (extendedMatch && childRouter) {\n            var restOfPath = getRestOfPath(extendedMatch, extendedPathReKeys);\n            childAction = childRouter.getActionForPathAndParams(restOfPath, inputParams);\n          }\n\n          return NavigationActions.navigate({\n            routeName: routeName,\n            params: getParamsFromPath(inputParams, exactMatch, exactReKeys),\n            action: childAction\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = paths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            _routeName = _step2$value[0],\n            _path = _step2$value[1];\n\n        var _extendedPathRe = _path.extendedPathRe,\n            _extendedPathReKeys = _path.extendedPathReKeys;\n        var _childRouter = childRouters[_routeName];\n\n        var _extendedMatch = _extendedPathRe && _extendedPathRe.exec(pathToResolve);\n\n        if (_extendedMatch && _extendedMatch.length) {\n          var _restOfPath = getRestOfPath(_extendedMatch, _extendedPathReKeys);\n\n          var _childAction = null;\n\n          if (_childRouter) {\n            _childAction = _childRouter.getActionForPathAndParams(_restOfPath, inputParams);\n          }\n\n          if (!_childAction) {\n            continue;\n          }\n\n          return NavigationActions.navigate({\n            routeName: _routeName,\n            params: getParamsFromPath(inputParams, _extendedMatch, _extendedPathReKeys),\n            action: _childAction\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  var getPathAndParamsForRoute = function getPathAndParamsForRoute(route) {\n    var routeName = route.routeName,\n        params = route.params;\n    var childRouter = childRouters[routeName];\n    var _pathsByRouteNames$ro = pathsByRouteNames[routeName],\n        toPath = _pathsByRouteNames$ro.toPath,\n        exactReKeys = _pathsByRouteNames$ro.exactReKeys;\n    var subPath = toPath(params);\n    var nonPathParams = {};\n\n    if (params) {\n      Object.keys(params).filter(function (paramName) {\n        return !exactReKeys.find(function (k) {\n          return k.name === paramName;\n        });\n      }).forEach(function (paramName) {\n        nonPathParams[paramName] = params[paramName];\n      });\n    }\n\n    if (childRouter) {\n      // If it has a router it's a navigator.\n      // If it doesn't have router it's an ordinary React component.\n      var child = childRouter.getPathAndParamsForState(route);\n      return {\n        path: subPath ? \"\".concat(subPath, \"/\").concat(child.path) : child.path,\n        params: child.params ? _objectSpread({}, nonPathParams, child.params) : nonPathParams\n      };\n    }\n\n    return {\n      path: subPath,\n      params: nonPathParams\n    };\n  };\n\n  return {\n    getActionForPathAndParams: getActionForPathAndParams,\n    getPathAndParamsForRoute: getPathAndParamsForRoute\n  };\n};","map":null,"metadata":{},"sourceType":"module"}