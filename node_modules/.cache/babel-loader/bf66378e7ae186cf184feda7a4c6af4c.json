{"ast":null,"code":"import _objectSpread from \"/Users/mkeohane/Documents/repositories/Tyes/website/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport invariant from '../utils/invariant';\nimport shallowEqual from '../utils/shallowEqual';\nvar SCENE_KEY_PREFIX = 'scene_';\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\n\nfunction compareKey(one, two) {\n  var delta = one.length - two.length;\n\n  if (delta > 0) {\n    return 1;\n  }\n\n  if (delta < 0) {\n    return -1;\n  }\n\n  return one > two ? 1 : -1;\n}\n/**\n * Helper function to sort scenes based on their index and view key.\n */\n\n\nfunction compareScenes(one, two) {\n  if (one.index > two.index) {\n    return 1;\n  }\n\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n/**\n * Whether two routes are the same.\n */\n\n\nfunction areScenesShallowEqual(one, two) {\n  return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);\n}\n/**\n * Whether two routes are the same.\n */\n\n\nfunction areRoutesShallowEqual(one, two) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(scenes, nextState, prevState, descriptors) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(function (scene) {\n    var route = scene.route;\n\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  }); // Bail out early if we didn't update the state\n\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  var prevScenes = new Map();\n  var freshScenes = new Map();\n  var staleScenes = new Map(); // Populate stale scenes from previous scenes marked as stale.\n\n  scenes.forEach(function (scene) {\n    var key = scene.key;\n\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n\n    prevScenes.set(key, scene);\n  });\n  var nextKeys = new Set();\n  var nextRoutes = nextState.routes;\n\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn('StackRouter provided invalid state, index should always be the top route');\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach(function (route, index) {\n    var key = SCENE_KEY_PREFIX + route.key;\n    var descriptor = descriptors && descriptors[route.key];\n    var scene = {\n      index: index,\n      isActive: false,\n      isStale: false,\n      key: key,\n      route: route,\n      descriptor: descriptor\n    };\n    invariant(!nextKeys.has(key), \"navigation.state.routes[\".concat(index, \"].key \\\"\").concat(key, \"\\\" conflicts with \") + 'another route!');\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    var prevRoutes = prevState.routes;\n\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn('StackRouter provided invalid state, index should always be the top route');\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    } // Look at the previous routes and classify any removed scenes as `stale`.\n\n\n    prevRoutes.forEach(function (route, index) {\n      var key = SCENE_KEY_PREFIX + route.key;\n\n      if (freshScenes.has(key)) {\n        return;\n      }\n\n      var lastScene = scenes.find(function (scene) {\n        return scene.route.key === route.key;\n      }); // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n\n      var descriptor = lastScene ? lastScene.descriptor : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index: index,\n          isActive: false,\n          isStale: true,\n          key: key,\n          route: route,\n          descriptor: descriptor\n        });\n      }\n    });\n  }\n\n  var nextScenes = [];\n\n  var mergeScene = function mergeScene(nextScene) {\n    var key = nextScene.key;\n    var prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n  nextScenes.sort(compareScenes);\n  var activeScenesCount = 0;\n  nextScenes.forEach(function (scene, ii) {\n    var isActive = !scene.isStale && scene.index === nextState.index;\n\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = _objectSpread({}, scene, {\n        isActive: isActive\n      });\n    }\n\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n  invariant(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (nextScenes.some(function (scene, index) {\n    return !areScenesShallowEqual(scenes[index], scene);\n  })) {\n    return nextScenes;\n  } // scenes haven't changed.\n\n\n  return scenes;\n}","map":null,"metadata":{},"sourceType":"module"}